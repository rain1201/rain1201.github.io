{"posts":[{"title":"Arch Linux安装","text":"1.安装Linux 使用图形界面安装Linux确实更为方便易行，但作为作业提交似乎又有一些简单。 Arch Linux仅用于本项作业，后续作业将基于Debian完成。 1.下载Linux镜像 使用TUNA镜像下载最新Arch Linux镜像 2.创建并启动虚拟机 在被Broadcom收购后，VMware不再收费了 使用VMware Workstation创建如下图所示虚拟机 成功启动虚拟机，选择第一项进入安装环境 3.测试互联网 Arch Linux作为一个滚动更新的发行版，一般需要联网安装以获得最新的软件。 4.配置镜像源 此处依然使用TUNA镜像源，用以加速下载。安装镜像自带了其他一些镜像源，需要先删除。 5.进行硬盘分区并挂载 硬盘分区 其中sda1作为交换分区，sda2为主分区，sda3为引导分区 格式化并挂载 将主分区挂载至/mnt 引导分区挂载至/mnt/boot 同时执行swapon /dev/sda1，开启交换分区 6.安装软件包 pacstrap是安装镜像自带的一个工具，依赖于 Pacman 的包管理功能，用于将软件包安装至指定位置。此处安装了基础软件包、Linux内核与驱动。 7. 配置fstab fstab文件记录了磁盘的挂载信息 1# genfstab -U /mnt &gt;&gt; /mnt/etc/fstab 8.配置引导 使用chroot切换至新安装系统，安装grub引导器，os-prober用于探测已安装系统 向硬盘安装grub并写入配置文件 同时设置root用户密码，以便重启后进行登录 重启，grub已经可以正确引导Arch 9.进行其他配置 使用root用户登录 启动网络并更新包管理器数据库 创建并切换至普通用户 为普通用户增加sudo 至此，Arch Linux的安装与基本配置已经完成。 心得 通过这次UNIX作业实践，我收获颇丰。通过手动安装Arch Linux，我深刻体会到Linux系统的灵活性：从磁盘分区到引导配置，每一个步骤都需要精确把控；镜像源配置和pacstrap安装让我对包管理机制有了直观认识，chroot环境操作也理解了系统层级隔离。","link":"/2025/03/22/Arch-Linux%E5%AE%89%E8%A3%85/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","link":"/2024/02/09/hello-world/"},{"title":"tp-link WR740漏洞复现","text":"前言 本项目旨在复现TP-Link WR740路由器固件中的漏洞。通过对固件进行解包、扫描和分析，最终实现漏洞的验证。整个过程涉及工具的安装与使用、代码的逆向分析以及模拟环境的搭建与测试。 0.问题分析 TP-Link WR740路由器存在一个严重的安全漏洞，允许攻击者通过特定的HTTP请求执行任意命令。这个漏洞存在于httpd程序中，通过对usr和passwd参数的验证不足，攻击者可以利用默认凭证进行未授权访问并执行命令。 1.固件获取 2.binwalk解包 环境 binwalk安装 binwalk 安装 123$ git clone https://github.com/ReFirmLabs/binwalk.git$ cd binwalk$ sudo python3 setup.py install sasquatch工具支持对 非标准的SquashFS格式的文件镜像 进行解压 sasquatch 安装 1234$ sudo apt-get install build-essential liblzma-dev liblzo2-dev zlib1g-dev$ git clone https://github.com/devttys0/sasquatch.git$ cd sasquatch$ ./build.sh sasquatch patch 12345cd patcheswget https://github.com/devttys0/sasquatch/files/7776843/M1-Kali.patch.txtpatch patch0.txt M1-Kali.patch.txtcd .../build.sh binwalk解包 $ binwalk -Me wr740nv1_en_3_12_4_up.bin 3.firmwalker扫描 获取firmwalker：git clone https://github.com/craigz28/firmwalker.git 路由器Web相关URL的格式为：/web/userRpm/* http服务器为httpd，且httpd中包含较多关键字符串，考虑对其进行分析 4.httpd反编译分析 使用IDA搜索passwd字符串，得到如下结果 第一个搜索结果仅有passwd，比较可疑，检查其引用。 在“passwd”附近还出现了“usr”字符串，以及“osteam”、“5up”两个意义不明的字符串，考虑将整个函数转换为C代码进行分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119int DebugResultRpmHtm(undefined4 param_1){ undefined4 *puVar1; int iVar2; short sVar8; char *pcVar3; char *pcVar4; size_t sVar5; ssize_t sVar6; undefined4 *puVar7; undefined4 uVar9; undefined4 uVar10; undefined4 uVar11; undefined4 *puVar12; undefined4 *puVar13; int iVar14; int iVar15; undefined4 local_c30 [5]; undefined2 local_c1c [1526]; undefined4 *local_30; undefined4 local_2c; undefined4 local_28; local_2c = 0x100; local_28 = 0; local_30 = local_c30; httpStatusSet(param_1,0); iVar14 = 0; httpHeaderGenerate(param_1); iVar15 = 0; iVar2 = HttpAccessPermit(param_1); if (iVar2 == 0) { sVar8 = HttpDenyPage(param_1); goto LAB_004816b4; } local_c30[0]._0_1_ = 0; if (pty_started != 0) { pcVar3 = (char *)httpGetEnv(param_1,&amp;DAT_0051717c); if (pcVar3 != (char *)0x0) { iVar2 = strcmp(pcVar3,&quot;exit&quot;); if (iVar2 != 0) { iVar2 = httpGetEnv(param_1,&quot;usr&quot;); if ((iVar2 != 0) &amp;&amp; (iVar2 = httpGetEnv(param_1,&quot;passwd&quot;), iVar2 != 0)) { pcVar4 = (char *)httpGetEnv(param_1,&quot;usr&quot;); iVar2 = strcmp(pcVar4,&quot;osteam&quot;); if (iVar2 == 0) { pcVar4 = (char *)httpGetEnv(param_1,&quot;passwd&quot;); iVar2 = strcmp(pcVar4,&quot;5up&quot;); if (iVar2 == 0) goto LAB_004813f8; } } puVar7 = local_c30; puVar1 = (undefined4 *)&quot;####User or Password not correct###\\\\n&quot;; do { puVar13 = puVar1; puVar12 = puVar7; uVar9 = puVar13[1]; uVar10 = puVar13[2]; uVar11 = puVar13[3]; *puVar12 = *puVar13; puVar12[1] = uVar9; puVar12[2] = uVar10; puVar12[3] = uVar11; puVar7 = puVar12 + 4; puVar1 = puVar13 + 4; } while (puVar13 + 4 != (undefined4 *)0x5171c0); *(undefined2 *)(puVar12 + 5) = *(undefined2 *)(puVar13 + 5); puVar12[4] = 0x2323235c; goto LAB_00481600; }LAB_004813f8: sVar5 = strlen(pcVar3); write(pty,pcVar3,sVar5); pcVar4 = strstr(pcVar3,&quot;ping&quot;); if ((pcVar4 != (char *)0x0) || ((pcVar4 = strstr(pcVar3,&quot;cat&quot;), pcVar4 != (char *)0x0 &amp;&amp; (pcVar3 = strchr(pcVar3,0x26), pcVar3 == (char *)0x0)))) { write(pty,&quot;&amp;&quot;,1); } write(pty,&amp;DAT_00512b9c,1); } taskDelay(10); do { sVar6 = read(pty,(void *)((int)local_c30 + iVar14),0x10); iVar15 = iVar15 + 1; if (sVar6 != 0x10) goto LAB_00481574; iVar14 = iVar14 + 0x10; } while (iVar15 != 0xa8); sVar6 = 0;LAB_00481574: if (1 &lt; sVar6 + 1U) { iVar14 = sVar6 + iVar14; } *(undefined *)((int)local_c30 + iVar14) = 0; while( true ) { puVar7 = (undefined4 *)strstr((char *)local_c30,&quot;\\r\\n&quot;); if (puVar7 == (undefined4 *)0x0) break; sVar5 = strlen((char *)((int)puVar7 + 2)); memmove(puVar7 + 1,(char *)((int)puVar7 + 2),sVar5 + 1); *puVar7 = 0x5c725c6e; } }LAB_00481600: httpPrintf(param_1, &quot;&lt;SCRIPT language=\\&quot;javascript\\&quot; type=\\&quot;text/javascript\\&quot;&gt;\\nvar %s = new Array(\\n&quot;, &quot;cmdResult&quot;); httpPrintf(param_1,&quot;\\&quot;%s\\&quot;,\\n&quot;,local_c30); httpPrintf(param_1,&quot;0,0 );\\n&lt;/SCRIPT&gt;\\n&quot;); HttpWebV4Head(param_1,0,0); iVar14 = httpRpmFsA(param_1,&quot;/userRpm/DebugResult.htm&quot;); if (iVar14 == 2) { return 2; } sVar8 = HttpErrorPage(param_1,10,0,0);LAB_004816b4: return (int)sVar8;} 注意到此函数将http请求中usr、passwd字段分别与“osteam”、“5up”比较，并执行http中cmd字段的命令 通过write(pty,cmd,strlen(cmd))来模拟执行命令。伪终端(pseudo terminal，有时也被称为 pty)是指伪终端 master 和伪终端 slave 这一对字符设备。其中的 slave 对应 /dev/pts/目录下的一个文件，而 master 则在内存中标识为一个文件描述符(fd)。伪终端由终端模拟器提供，终端模拟器是一个运行在用户态的应用程序。可通过写pty文件执行指令。 用IDA Pro对httpd程序进行反编译分析。搜索关键字符串如passwd，并分析相关函数，发现漏洞点在于对usr和passwd字段的验证不足，且可以通过pty伪终端执行命令。 检查该函数调用情况，发现url绑定 5.模拟验证 环境 由于涉及分区挂载操作，FirmAE不能在WSL下运行。 FirmAE安装 123$ git clone --recursive https://github.com/pr0v3rbs/FirmAE$ ./download.sh$ ./install.sh 模拟 先检查能否模拟 然后进行模拟 访问前面发现的url，根据提示输入默认账号密码，发现可以执行命令 6. 结论 通过对TP-Link WR740路由器固件的详细分析与模拟测试，成功复现了固件中的漏洞。本文展示了从固件获取、解包、扫描到漏洞分析和模拟验证的全过程，为进一步的安全研究提供了实践案例。 7. 参考文献 Binwalk GitHub Repository: https://github.com/ReFirmLabs/binwalk Firmwalker GitHub Repository: https://github.com/craigz28/firmwalker FirmAE GitHub Repository: https://github.com/pr0v3rbs/FirmAE TP-Link WR740 后门漏洞复现（学习记录）:TP-Link WR740 后门漏洞复现（学习记录）-智能设备-看雪-安全社区|安全招聘|kanxue.com","link":"/2024/05/07/WR740%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"title":"强化学习综述","text":"摘 要 强化学习作为一种受到人类自然学习过程启发的机器学习方式，已经成为一种解决策略探索问题的主要方法。通过学习强化学习的基本概念与组成、分析相关常用算法的基本原理、展望前景与前沿挑战共三个方面概述分析强化学习，期望在完成作业的同时为对该领域一无所知的人提供有限的启发。 关键词 强化学习；策略搜索；神经网络 A Review of Reinforcement Learning Abstract Reinforcement learning, as a machine learning method inspired by the natural learning process of humans, has become a major approach for solving problems related to strategy exploration. By learning the basic concepts and components of reinforcement learning, analyzing the basic principles of commonly used algorithms, and looking forward to the prospects and frontier challenges, this article provides an overview and analysis of reinforcement learning, with the expectation of providing limited inspiration for those who know nothing about this field while completing the assignment. Key words Reinforcement learning; Policy search; Neural networks 在生物进化的过程中，物种的学习能力不断增强。而任何一个物种的学习，都离不开与自然环境的交互。他们在自然环境中进行行为的选择，根据不同行为选择获得不同的回报。再此过程中他们逐渐获得了对特定环境情况的判断能力，也就是习得了新技能。如果根据拉马克的用进废退理论，这种能力还会在亲子代间遗传，从而使整个种群不断进化。 虽然以现代科学的视角来看，拉马克的观点存在一定的局限性，但这并不妨碍其观点为当代人工智能的研发提供灵感。强化学习过程便与生物在环境中进行交互式学习有异曲同工之妙。在计算过程中，强化学习试图尽可能提高自身与环境交互而产生的收益总量。强化学习会从过往训练过程中获取信息并对自身进行修正，以此提高下一次预测的预期收益。 1 强化学习基础概念 1．1 强化学习 强化学习主要解决一个智能体如何在一个不确定的环境中通过与环境的交互而获得尽可能多的收益的问题。它通过收集环境信息，指导更好的动作。这种在交互中学习的方法被称为强化学习。 1．2 基本元素 1．2．1 环境与智能体 环境是智能体观察、感知、交互的外部系统。智能体处于环境中，能通过采取行动来改变环境。 1．2．2 状态与观察值 ​ 两者均描述环境。不同之处在于状态是对环境的完全描述，不会遗漏任何信息。而观察值可能是对环境的有限描述，可能仅包含环境的部分信息。 1．2．3 动作 ​ 不同的环境允许智能体进行不同的活动，其允许的有效动作的集合被称作动作空间，可分为离散动作空间和连续动作空间。 1．2．4 奖励 ​ 奖励是由环境给予智能体的反馈信号，是一个标量，可用于评价智能体在某一步采取动作的表现如何。 1．3 术语 1．3．1 策略 策略用于根据当前状态决定下一步执行的动作，可以是确定的或随机的，分别表示为： at=μ(st) at~π(st) 1．3．2 状态转移 用于衡量在当前环境和行动下，系统状态向某一状态转移的可能性。一般是随机的。可以使用状态密度函数表示： p(s| s, a)=P(S=s` | S=s, A=a) 1．3．3 回报 回报是对奖励的加权求和。因为未来的奖励具有不确定性，距现在越远的奖励不确定性越强。因此引入折扣率γ，减弱未来的奖励对当下回报计算的影响： Ut= Rt+γ2Rt+1+γ3Rt+2+…… 1．3．4价值函数 可分为状态价值函数和动作价值函数。前者在给定策略的情况下衡量当前当前状态的好坏；后者在给定策略和状态的情况下衡量某一动作的好坏。 2 强化学习算法 2．1 算法分类 按照环境是否已知划分，强化学习算法可分为免模型学习和有模型学习。前者不会尝试模拟环境，而后者会通过模拟环境来预判采取某个行动会发生的情况。一般来说，环境是难以模拟的，所以主要研究无模型学习。 按照学习方式划分，强化学习算法可分为在线策略和离线策略。前者必须由智能体与环境交互并学习；后者则可以观察其他个体与环境交互而进行学习。 按照学习目标划分，强化学习算法可分为基于策略和基于价值。前者直接根据概率选择动作，后者选择价值较高的动作。两者可以进行结合 2．2 Q-Learning 2．2．1 概述 Q-Learning是一种基于表格而没有神经网络参与的算法。它通过每次尝试更新Q值表，并以此指导行动。 2．2．2 算法流程 1．初始化动作价值函数Q(s,a)，其中s代表状态，a代表选择的动作。 2．依照状态s根据Q及其他策略（例如ε贪婪策略）选择动作a 3．执行动作a，观察当前状态s`与收益r 4．更新 Q(s,a)=Q(s,a)+α[r+γmaxaQ(s,a`)-Q(s,a)] s=s` 其中α为学习率, maxaQ(s,a`)代表从下一动 作中预期获得的最大收益。 5．重复2，3，4 2．2．3 ε贪婪策略 在开始时，Q(s,a)被初始化的方式可能与最优解相差很远，这可能导致学习缓慢。因此，需要权衡随机探索与利用已有经验的程度。此时，可以使用ε贪婪策略。ε表示在某一步时使用随机行动的概率。 开始时，将ε设定为1，即完全随机。这可以为Q函数的构建提供丰富的学习资源。随着训练的进行，Q函数变得更为准确，此时可以逐步缩小ε，更多地由Q函数决定采取的行动。 2．2．4 Q值表 Q的函数值是由s与a共同决定的，且在Q-Learning中，s与a都是离散的。这使得我们可以通过一张二维表格将Q函数完整表示。表格中的一维是环境的所有状态，另一维是能够采取的动作，中间则为Q值。 事实上，通过Q函数选择动作的过程就是在Q值表中选取当前状态对应的一行，找到该行中最大的Q值，并采取其列对应的动作。 2．3 Deep Q Network 2．3．1 概述 Q-Learning使用Q值表来保存Q值，这对于有较多状态的环境或连续的动作是不现实的。在DQN中，神经网络替代了Q值表，接受状态s与动作a并给出预测的Q值。 2．3．2 存在问题 1．一个极小的变化可能引起对动作选择的很大影响。 2．对于连续动作，选择最大的Q值仍比较困难。 3．无法学习到随机策略。 2．4 Policy Gradient 2．4．1 综述 在Q-learning和DQN中，计算Q值（预期收益）都是必不可少的过程，同时也是限制算法应用的一大障碍。如果能够直接根据状态选择动作，就可以避免计算Q值带来的限制，这也就是Policy Gradient。 Policy Gradient算法是一种基于梯度优化的强化学习算法。它通过优化策略来最大化预期奖励，通常用于处理连续动作空间的问题。 Policy Gradient算法使用代表状态和行动的神经网络来决定策略。该算法通过多次采样，根据每个样本的回报来计算损失函数。然后使用梯度上升来更新代理策略网络的参数，以最小化损失。 2．4. 2 算法概述 首先，初始化代理策略网络参数，然后根据当前策略生成多个样本路径。对每个样本路径计算其总收益，并将其作为回报。根据计算所得的回报，计算损失函数，并对其进行梯度计算。最后，使用梯度上升来更新代理策略网络的参数。 3 局限性 Policy Gradient算法通常需要多次采样以获得损失函数的近似值，因此计算效率相对较低。此外，Policy Gradient算法也容易受到过拟合和噪声干扰等问题的影响。为了解决这些问题，可以考虑采用正则化、调整学习率等方法来优化算法的性能。 普通的Policy Gradient算法，只适合于解决规模较小的问题，比如让杆子竖起来。如果想应用到更复杂的问题上，就需要更复杂的一些方法，比如的Actor Critic，Asynchronous Advantage Actor-Critic (A3C)。 3前景展望 强化学习，作为人工智能领域中的一个重要分支，已经展示了其在许多领域的巨大潜力和前景。无论是自动驾驶汽车、智能家居系统、还是游戏AI，强化学习算法都在解决复杂的决策问题方面表现出色。然而，强化学习也面临着一系列挑战，其中最主要的包括样本效率问题、探索与利用的平衡、以及稳定性与收敛性等。 样本效率问题是强化学习算法在大量样本数据中进行学习的问题。为了获得最佳的学习效果，算法需要大量的样本数据进行训练，这无疑增加了算法的复杂性和运行成本。探索与利用的平衡问题则是指在探索新的可能性和利用已有知识之间找到一个平衡。过于探索可能导致算法失去方向，而过于利用则可能导致算法陷入局部最优解。 稳定性与收敛性也是强化学习算法面临的挑战。在面对复杂环境和决策空间时，强化学习算法可能会出现不稳定的情况，即在不同运行中得到的结果差异较大。而收敛性则是指算法能否在有限的步骤或时间内找到最优解。 为了解决这些问题，研究人员正在不断探索新的方法和算法。例如，一些研究人员正在尝试将强化学习与其他机器学习技术相结合，以提高算法的效率和稳定性。此外，还有一些研究人员正在探索新的优化策略，以更好地平衡探索和利用，以及提高算法的收敛速度和稳定性。 尽管存在这些挑战，但强化学习在许多领域的应用前景仍然非常广阔。它将继续推动自动化系统的革命，改善我们的生活和工作方式。同时，它不仅仅局限于传统机器人领域，还能扩展至金融、医疗、游戏和教育等多个领域，以改善决策和解决优化问题。 我们期待未来的研究人员能够克服强化学习的这些挑战，提出新的算法和技术，以改进其稳定性和可解释性。随着时间的推移，强化学习有望在不同领域带来更多创新和智能化解决方案，为未来的科技发展带来更广阔的可能性。无论是在自动驾驶汽车的安全性、智能家居系统的智能化水平、还是在游戏AI的表现上，强化学习都将为我们带来更多的惊喜和突破。 致谢 感谢老师对我的指导和鼓励，让我有机会深入了解强化学习这一领域。在完成这篇综述的过程中，我不仅学习了强化学习的基本概念、算法和应用，还对相关领域的研究进展有了更深入的了解。 同时，也感谢老师对我的信任和支持，让我有机会参与一些研究项目和学术活动，进一步拓宽了我的视野和知识面。 此外，我还要感谢我的同学们和朋友们，在我们的讨论和交流中，我得到了很多启发和思路。同时，也感谢他们对我的支持和鼓励，让我有信心面对学习和生活中的挑战。 再次感谢所有帮助和支持过我的人，我会继续努力学习和研究，不断提高自己的能力和水平。 参 考 文 献 [1] 强化学习入门：基本思想和经典算法, https://zhuanlan.zhihu.com/p/466455380 [2] 强化学习入门, https://blog.csdn.net/CltCj/article/details/119445005 [3] 【强化学习】Q-Learning算法详解, https://blog.csdn.net/qq_30615903/article/details/80739243 [4] 如何理解策略梯度（Policy Gradient）算法, https://zhuanlan.zhihu.com/p/110881517 [5] 强化学习专栏 第七讲 策略梯度, https://zhuanlan.zhihu.com/p/515290741 [6]Wang Yao, Luo Junren, Zhou Yanzhong, et al. Review and Analysis of Reinforcement Learning and Evolutionary Computing Methods for Policy Exploration [J/OL]. Computer Science: 1-23 [2023-12-05] (王尧,罗俊仁,周棪忠等.面向策略探索的强化学习与进化计算方法综述分析[J/OL].计算机科学:1-23[2023-12-05].http://kns.cnki.net/kcms/detail/50.1075.TP.20230925.1333.082.html.) [7]Jiang Ying, Qi Yunsong. Overview of knowledge graph completion technology and applications for deep learning in artificial intelligence [J/OL]. Computer Measurement and Control: 1-13 [2023-12-05] (姜颖,祁云嵩.面向人工智能深度学习的知识图谱补全技术与应用综述[J/OL].计算机测量与控制:1-13[2023-12-05].http://kns.cnki.net/kcms/detail/11.4762.TP.20231017.1430.006.html.) Background Reinforcement learning has a wide range of applications, including robotics, game playing, autonomous driving, and recommendation systems. It has been used to develop agents that can play complex games like Go, at a superhuman level, navigate through complex environments, and optimize energy consumption in buildings. There are several challenges associated with reinforcement learning, including the exploration-exploitation trade-off and generalization. Researchers have developed various techniques to address these challenges, such as policy gradients, and deep reinforcement learning. They are all such powerful and creative solutions that I could never imagine. Unfortunately, this article will not improve the solutions to the questions above. Neither did the article discover any valuable problems to be explored. As is said in the abstract part, the meaning of the article is just to help the people with really poor knowledge of reinforcement learning in addition to finishing the assignment and getting the credits","link":"/2024/05/09/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BB%BC%E8%BF%B0/"},{"title":"剪刀石头布dapp开发","text":"1. 实验任务和需求 开发一个剪刀石头布的智能合约，实现以下功能或特性： （1）实现剪刀石头布游戏的基本逻辑，正确判断游戏结果。 （2）将玩家提交的信息加密（暂且将取hash作为加密）储存在区块中，尽可能避免作弊。 （3）尽可能保证合约在输入非法的情况下仍能运行。 （4）使合约具有一定的可复用性。 并开发与之配套的前端程序，使合约易于使用。 2. 概要设计（实验思路） （1）使用bet函数判断用户能否加入游戏，如果可以则保存用户的地址与提交的hash （2）使用reveal函数接收用户对自己选择的披露并进行校验 （3）使用getreward函数给用户发放奖励 3. 详细设计（关键算法） （1）全局数据结构： address payable[2] player;//当前玩家地址 bytes32[2] p;//hash加密下注情况 uint[2] value;//下注金额 uint8[2] chosed;//玩家选择手势，1：剪刀 2石头 3布 uint8 numberOfPlayer;//当前玩家数量 uint8 winner;//2：未决定，3：平局，1：玩家1，0：玩家0 uint timeout;//超时时间 uint finishtime;//玩家完成提交hash时间 uint MinValue;//最小下注金额 （2）只有当玩家数量不足或上一局玩家超时过长（4倍timeout）时，bet函数才会允许新玩家加入。如果情况属于后者，则还会将下注金额分别退还给上一局两位玩家，并进行重置。同时，bet函数不允许玩家对提交内容进行修改，与现实较为一致。 （3）reveal函数对输入取hash，并与bet保存的hash比较，如果一致，则储存输入。 （4）getwinner函数判断胜者，此函数中硬编码了所有合法的情况，并会将其他情况判定为平局。 （5）getreward函数首先判断是否达到获取奖励的条件，即是否游戏双方都完成了披露、调用者是否为胜者，然后进行先更改余额再进行转账并重置合约。如果平局，则双方可分别拿回自己的下注。如果超时且仅有一方披露，则认为该方为胜者。如果超时且两方均未披露，则认为平局。 （6）reset用于重置合约状态，设置为internal以防止外部恶意调用 generatehash用于创建执行bet函数所需的hash，设置为pure，执行情况不会被记录 getinfo用于获取合约状态，主要用于前端展示，设置为view user用于获取玩家编号（0，1），非当前玩家调用会导致错误 4. 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137pragma solidity ^0.5.0;/// @title 猜拳合约/// @author sry/// @dev 仅在有限的测试中没有发生错误contract putETH { address payable[2] player;//玩家地址 bytes32[2] p;//hash加密下注情况 uint[2] value=[0,0];//下注金额 uint8[2] chosed=[0,0];//1：剪刀 2石头 3布 uint8 numberOfPlayer = 0; uint8 winner=2;//2：未决定，3：平局，1：玩家1，0：玩家0 uint timeout=30 minutes; uint finishtime=now; uint MinValue=1 wei; /// @notice 用户下注 /// @param hash 用户下注信息,传入应当为keccak256(abi.encodePacked(uint8 choose,uint secret)) /// @return hash function bet(bytes32 hash) public payable returns(bytes32){ if(now&gt;=finishtime+4*timeout &amp;&amp; msg.sender!=player[0]&amp;&amp;msg.sender!=player[1]){ uint refund; refund=value[0]; value[0]=0; player[0].transfer(refund); refund=value[1]; value[1]=0; player[1].transfer(refund); reset(); } if (numberOfPlayer&gt;=2)revert(); if (msg.value&lt;MinValue)revert(); if (numberOfPlayer==1 &amp;&amp; msg.sender==player[0])revert(); numberOfPlayer=numberOfPlayer+1; value[numberOfPlayer-1]=msg.value; p[numberOfPlayer-1]=hash; player[numberOfPlayer-1]=msg.sender; finishtime=now; return hash; } /// @notice 用户披露下注情况 /// @param choose 用户选择的手势 /// @param secret 用户自定密钥 /// @return choose function reveal(uint8 choose,uint secret) external returns(uint){ uint8 user=user(msg.sender); if (p[user]==keccak256(abi.encodePacked(choose, secret))) { chosed[user]=choose; }else revert(); return choose; } /// @notice 获取奖励，平局分别取回 /// @return reward 奖励值 function GetReward() external returns(uint){ uint reward=0; if((chosed[0]==0 || chosed[1]==0) &amp;&amp; now&lt;finishtime+timeout){ revert(); } if(now&gt;=finishtime+timeout &amp;&amp; (chosed[0]==0 || chosed[1]==0)){ uint8 user=user(msg.sender); if(chosed[0]==0 &amp;&amp; chosed[1]==0){ winner=3; } else{ if(chosed[user]==0)revert(); reward=value[0]+value[1]; value[0]=0; value[1]=0; player[user].transfer(reward); reset(); return reward;} } if(winner==2)winner=getwinner(); require(winner!=2); if(winner!=3){ if(msg.sender!=player[winner])revert(); reward=value[0]+value[1]; value[0]=0; value[1]=0; player[winner].transfer(reward); reset(); }else { uint8 user=user(msg.sender); reward=value[user]; value[user]=0; msg.sender.transfer(reward); if(value[0]==0 &amp;&amp; value[1]==0)reset(); } return reward; } /// @notice 计算胜者 /// @dev reveal()并没有检查choose的值是否合法，在此函数中，不合法的输入会被判定为平局 /// @return user 胜者编号 function getwinner() public view returns(uint8){ if(chosed[0]==chosed[1]){ return 3; } else if((chosed[0]==2 &amp;&amp; chosed[1]==1) || (chosed[0]==1 &amp;&amp; chosed[1]==3) || (chosed[0]==3 &amp;&amp; chosed[1]==2)){ return 0; } else if((chosed[1]==2 &amp;&amp; chosed[0]==1) || (chosed[1]==1 &amp;&amp; chosed[0]==3) || (chosed[1]==3 &amp;&amp; chosed[0]==2)){ return 1; } return 3; } /// @notice 重置 function reset() internal { numberOfPlayer=0; chosed[0]=0; chosed[1]=0; winner=2; finishtime=now; } /// @notice 获取用户编号 /// @dev 调用用户非当前玩家会导致revert /// @param t 用户地址 /// @return user 用户编号 function user(address t) internal view returns(uint8){ if(t==player[0]){return 0;} else if(t==player[1]){return 1;} else revert(); } /// @notice 获取当前信息 /// @return player,value,chosed function GetInfo() public view returns(address,address,uint,uint,uint8,uint8){ return (player[0],player[1],value[0],value[1],chosed[0],chosed[1]); } /// @notice 生成hash /// @dev 函数声明为pure，执行情况不会被记录 /// @param choose 选择手势 /// @param secret 密码 /// @return x 生成的hash function GenerateHash(uint8 choose,uint secret) pure public returns(bytes32){ bytes32 x; x=keccak256(abi.encodePacked(choose,secret)); return x; }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;style&gt; /*--预设--*/ body { padding:0px;margin: 0px; } #lyrow, #lyrow input, #lyrow textarea { font-size:12px;font-family: 'Microsoft YaHei', '微软雅黑', MicrosoftJhengHei, '华文细黑', STHeiti, MingLiu; } #lyrow { height:100vh;width: 100vw; } #lyrow div { min-height: 18px; } #lyrow input, #lyrow textarea { border:rgb(235, 235, 235) 1px solid;border-radius: 3px;padding: 5px 8px;outline: 0; } #lyrow input:hover, #lyrow textarea:hover { border: 1px solid #6bc1f2; } /*--编辑--*/ &lt;/style&gt; &lt;div id=&quot;lyrow&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;button&quot; value=&quot;连接metamask&quot; id=&quot;connect&quot; &gt; &lt;span &gt;选择手势：&lt;/span&gt; &lt;select name=&quot;select&quot; id=&quot;choose&quot; &gt; &lt;option value=&quot;1&quot;&gt;剪刀&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;石头&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;布&lt;/option&gt; &lt;/select&gt; &lt;span &gt;选择账号：&lt;/span&gt; &lt;select name=&quot;select&quot; id=&quot;acc&quot; &gt; &lt;/select&gt; &lt;span &gt;下注金额(eth,支持小数)：&lt;/span&gt; &lt;input type=&quot;text&quot; name=&quot;input&quot; oninput=&quot;value=value.replace(/[^\\d.]/g,'')&quot; id=&quot;val&quot; value=&quot;1&quot;&gt; &lt;span &gt;随机数：&lt;/span&gt; &lt;input type=&quot;text&quot; name=&quot;input&quot; oninput=&quot;value=value.replace(/[^\\dabcdefx]/g,'')&quot; id=&quot;ran&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;button&quot; value=&quot;获取当前状态&quot; id=&quot;getinfo&quot; &gt; &lt;input type=&quot;submit&quot; name=&quot;button&quot; value=&quot;下注&quot; id=&quot;bet&quot; &gt; &lt;input type=&quot;submit&quot; name=&quot;button&quot; value=&quot;披露下注情况&quot; id=&quot;reveal&quot; &gt; &lt;input type=&quot;submit&quot; name=&quot;button&quot; value=&quot;查看结果&quot; id=&quot;getwinner&quot; &gt; &lt;input type=&quot;submit&quot; name=&quot;button&quot; value=&quot;获取奖励&quot; id=&quot;getreward&quot; &gt; &lt;/div&gt; &lt;div id=&quot;player-content&quot;&gt; &lt;/div&gt; &lt;script src=&quot;js/web3.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258$(function() { var account = null; var web3 = null; const address = '0xb92b82a94382b9110e8febBEd4AEfB7F3436a26F';//'0xa7228a391b6B0E343C33F6aE5A511Eefaf540688';//'0xd6C500DccEF6B65eF956B7446a405cbed4c47814' ;// 合约部署地址 var contract =null; var choose=0; var r=null; const abi =[ { &quot;constant&quot;: true, &quot;inputs&quot;: [ { &quot;internalType&quot;: &quot;uint8&quot;, &quot;name&quot;: &quot;choose&quot;, &quot;type&quot;: &quot;uint8&quot; }, { &quot;internalType&quot;: &quot;uint256&quot;, &quot;name&quot;: &quot;secret&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;name&quot;: &quot;GenerateHash&quot;, &quot;outputs&quot;: [ { &quot;internalType&quot;: &quot;bytes32&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bytes32&quot; } ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; }, { &quot;constant&quot;: true, &quot;inputs&quot;: [], &quot;name&quot;: &quot;GetInfo&quot;, &quot;outputs&quot;: [ { &quot;internalType&quot;: &quot;address&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;address&quot; }, { &quot;internalType&quot;: &quot;address&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;address&quot; }, { &quot;internalType&quot;: &quot;uint256&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint256&quot; }, { &quot;internalType&quot;: &quot;uint256&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint256&quot; }, { &quot;internalType&quot;: &quot;uint8&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint8&quot; }, { &quot;internalType&quot;: &quot;uint8&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint8&quot; } ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; }, { &quot;constant&quot;: false, &quot;inputs&quot;: [], &quot;name&quot;: &quot;GetReward&quot;, &quot;outputs&quot;: [ { &quot;internalType&quot;: &quot;uint256&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;nonpayable&quot;, &quot;type&quot;: &quot;function&quot; }, { &quot;constant&quot;: false, &quot;inputs&quot;: [ { &quot;internalType&quot;: &quot;bytes32&quot;, &quot;name&quot;: &quot;hash&quot;, &quot;type&quot;: &quot;bytes32&quot; } ], &quot;name&quot;: &quot;bet&quot;, &quot;outputs&quot;: [ { &quot;internalType&quot;: &quot;bytes32&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bytes32&quot; } ], &quot;payable&quot;: true, &quot;stateMutability&quot;: &quot;payable&quot;, &quot;type&quot;: &quot;function&quot; }, { &quot;constant&quot;: true, &quot;inputs&quot;: [], &quot;name&quot;: &quot;getwinner&quot;, &quot;outputs&quot;: [ { &quot;internalType&quot;: &quot;uint8&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint8&quot; } ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; }, { &quot;constant&quot;: false, &quot;inputs&quot;: [ { &quot;internalType&quot;: &quot;uint8&quot;, &quot;name&quot;: &quot;choose&quot;, &quot;type&quot;: &quot;uint8&quot; }, { &quot;internalType&quot;: &quot;uint256&quot;, &quot;name&quot;: &quot;secret&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;name&quot;: &quot;reveal&quot;, &quot;outputs&quot;: [ { &quot;internalType&quot;: &quot;uint256&quot;, &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;nonpayable&quot;, &quot;type&quot;: &quot;function&quot; }]; function handleAccountsChanged(accounts) { var acc=document.getElementById(&quot;acc&quot;); if (accounts.length === 0) { console.log('Please connect to MetaMask.'); } else{ acc.innerHTML=&quot;&quot;; for (var a=0; a&lt;accounts.length;a++){ acc.innerHTML+=`&lt;option value=&quot;${accounts[a]}&quot;&gt;${accounts[a]}&lt;/option&gt;\\n`; }; account = acc.value; console.log(account); } } function changeaccount(){ var acc=document.getElementById(&quot;acc&quot;); account = acc.value; console.log(account); } function connect(){ ethereum .request({ method: 'eth_requestAccounts' }) .then(handleAccountsChanged) .catch((err) =&gt; { if (err.code === 4001) { console.log('Please connect to MetaMask.'); } else { console.error(err); } }); web3 = new Web3(window.web3.currentProvider); contract= new web3.eth.Contract(abi, address); } function bet(){ var sel=document.getElementById(&quot;choose&quot;); var val=document.getElementById(&quot;val&quot;); var ran=document.getElementById(&quot;ran&quot;); var hash; web3.utils.randomHex(32); contract.methods.GenerateHash(sel.value,parseInt(ran.value)).call().then(function(result) { hash=result;//web3.utils.hexToAscii(result); console.log(hash); contract.methods.bet(hash).send({ from: account,gasPrice: &quot;1000000000&quot;,value: String(parseFloat(val.value)*1000000000000000000) }) .on('error', function(error, receipt) {alert(error,receipt);return;}) .on('receipt', (data) =&gt; { console.log(data); }); }); sel.disabled=true; val.disabled=true; ran.disabled=true; } function reveal(){ var sel=document.getElementById(&quot;choose&quot;); var val=document.getElementById(&quot;val&quot;); var ran=document.getElementById(&quot;ran&quot;); contract.methods.reveal(sel.value,parseInt(ran.value)).send({from: account,gasPrice: &quot;1000000000&quot;}) .on('error', function(error, receipt) {alert(error,receipt);return;}) .then(function(result) { console.log(result); }); sel.disabled=false; val.disabled=false; ran.disabled=false; } function getreward(){ var sel=document.getElementById(&quot;choose&quot;); contract.methods.GetReward().send({from: account,gasPrice: &quot;1000000000&quot;}) .on('error', function(error, receipt) {alert(error,receipt);return;}) .then(function(result) { console.log(result); }); } function getinf(){ var res=[&quot;have not revealed&quot;,&quot;剪刀&quot;,&quot;石头&quot;,&quot;布&quot;]; contract.methods.GetInfo().call().then(function(result) { console.log(result); alert(&quot;player 0:&quot;+result[0]+&quot;\\n&quot;+ &quot;player 1:&quot;+result[1]+&quot;\\n&quot;+ &quot;value 0:&quot;+result[2]+&quot;\\n&quot;+ &quot;value 1:&quot;+result[3]+&quot;\\n&quot;+ &quot;choose 0:&quot;+res[parseInt(result[4])]+&quot;\\n&quot;+ &quot;choose 1:&quot;+res[parseInt(result[5])]+&quot;\\n&quot; ); }); } function getwinner(){ var res=[&quot;player 0 wins&quot;,&quot;player 1 wins&quot;,&quot;have not decided&quot;,&quot;draw/other situations&quot;]; contract.methods.getwinner().call().then(function(result) { alert(res[parseInt(result)]); }); } $(&quot;#connect&quot;).on('click', connect); $(&quot;#getinfo&quot;).on('click', getinf); $(&quot;#bet&quot;).on('click', bet); $(&quot;#reveal&quot;).on('click', reveal); $(&quot;#getwinner&quot;).on('click', getwinner); $(&quot;#getreward&quot;).on('click', getreward); $(&quot;#acc&quot;).on('change', changeaccount); document.getElementById(&quot;ran&quot;).value=Web3.utils.randomHex(32); }) 5. 测试方案 创建两个账户模拟两个玩家进行游戏，注意完全模拟输赢和平局情况，并模拟一些非法输入或超时的情况。创建第三个账户，模拟非玩家调用情况。将合约部署至测试链，将前端部署至服务器，测试前端工作情况。 6. 测试过程 先在remix vm中进行测试。 （secret的类型为uint256，实际前端会随机生成32byte作为secret，足够安全。为了测试方便使用较简单的secret） 生成hash： ​ 下注及执行后情况： ​ 披露： 对另一账号进行相似操作，得结果： （超时处理的效果难以展示，从略） 7. 结果分析 在有限的测试中，合约和前端都正常工作。合约能够正确执行游戏逻辑，并具有一定的安全性和抵抗非法输入的能力。前端能够与合约恰当配合，具有一定的易用性。 8. 总结 本实验设计了一个剪刀石头布的智能合约，并配套开发了前端页面，且进行了相关测试，基本完成了实验的目标与需求。 但是受限于开发时间、开发条件等因素，本实验也存在许多可完善之处。例如合约中超时处理的逻辑可以进一步优化，合约整体可以进一步优化以节省gas，前端较为简陋，前端与合约的交互可以通过event而不一定是函数返回值。这些问题有待于进一步解决完善。 在此实验中，Microsoft Azure提供了托管前端的服务器资源、Cloudflare提供了域名解析与CDN服务、ethereum.org提供了智能合约的集成开发与测试环境、智谷提供了合约最终部署环境，在此一并向它们表示感谢。","link":"/2024/05/09/%E5%89%AA%E5%88%80%E7%9F%B3%E5%A4%B4%E5%B8%83dapp%E5%BC%80%E5%8F%91/"},{"title":"密码学考试计算器使用指南","text":"0.前言 无论是何种加密体制，其加密和解密过程往往需要一定的计算量。考虑到这一点，密码学相关的考试一般允许携带计算器以辅助计算。然而，现在常见的科学计算器一般为计算连续函数设计，对密码学所需的离散数学计算支持甚少。并且密码学教学过程中常假定计算执行的平台是计算机而非考试使用的普通科学计算器，导致课程中提及的计算优化方法不一定适用于考试。考虑到上述种种困境，本文介绍了一些密码学考试中的计算器使用方法，希望能够减轻密码学考试带来的计算方面的痛苦。 本文基于广泛使用的Casio fx-991CN X计算器进行介绍，其官方说明书可以从这里获得。 1. 约定与基础知识 对于某个计算机算法，我们往往以其复杂度来衡量其优劣。若我们以相同的方法衡量算法在计算器上的执行效果，则会发现两个问题： 复杂度衡量的是数据极大时计算量的增长情况，但我们的数据常常没有那么大。 复杂度衡量的是计算机的计算次数，而我们更关心计算时需要输入的字符量，因为输入会占据计算的大部分时长。 因此，我们以输入的算式条数作为复杂度衡量依据。此处不适用字符数是考虑到字符数难以准确计数，且每个人使用习惯不同，相同的算式也有多种不同的方式进行输入。 计算器通常有一定精度的限制，超出部分会被省略，本文以10位有效数字为例。注意这并不意味着计算器只能处理1010以内的数字，过大的数字会被转化为科学计数法。 ÷ R是一个一般不常用但在本文中十分重要的运算符，它类似于Python中的divmod函数，可以同时返回除法的商和余数，例如5 ÷ R3 = 1, R = 2.若无特殊说明，后文 mod 计算均使用此运算符实现。如果 ÷ R的结果需要进行下一步计算或被赋值到寄存器，它仅会返回商，例如(5÷R3) × 2 = 1 × 2 = 2。如果希望计算余数，则可以使用 $a =a-p(a ) $. FACT可以将整数进行质因数分解。但需注意你需要先获得一个结果（按下等于按键），然后才能进行质因数分解,质因数分解的结果也不会被保存在历史记录中。 计算器常会提供寄存器以储存计算过程中的中间结果。本文以大写字母A至F表示这些寄存器，以a → A表示寄存器赋值操作。 :可以用于连接多个算式，计算时每个算式会被依次计算并输出结果。我们可以使用其与寄存器结合构造多条语句的循环。需要注意:在历史记录中会被保存为多条算式，导致无法被复用。同时输入时需要注意第一条算式不能是合法的语句，否则会被直接执行，可以通过在算式开头加一个 ×来绕过。 2.快速幂优化 在课程中，快速幂算法往往被等同于平方-乘算法，这事实上并不全面。我们也可以实现类似的“立方-乘算法”。 1234567891011121314151617def cubic_exponentiation(base, exponent, modulus): result = 1 base = base % modulus # 先对底数取模 while exponent &gt; 0: # 如果当前最低位是1 if exponent % 3 == 1: result = (result * base) % modulus elif exponent % 3 == 2: result = (result * base * base) % modulus # 指数右移（除以3） exponent = exponent // 3 # 计算base的立方 base = (base * base * base) % modulus return result 使用计算器计算时，我们可以使用“m次方-乘”算法，其中m可以被动态确定。我们希望用一条算式计算尽可能大的次方结果，但这受到有效数字位数的限制。容易知道，计算时，想要获得不损失精度的结果，需要一次计算的am &lt; 1010即取$m = \\lfloor\\frac{10}{\\log_{10}{a}}\\rfloor$.当然我们并不需要真的使用上式进行计算，直接计算 ak ,根据结果直接估算就可以获得较好的效果。 例如计算 1320 mod 23 直接计算 1320 ≈ 1.90 × 1022 估算 138 &lt; 1010,计算138 ÷ R23 = 35466553, R = 2 考虑 1320 = 138 * 2 + 4,计算 (134*22) ÷ R23 = 4976, R = 3 最终解得 1320 mod 23 = 3 如果使用传统的“平方-乘”算法，则需要依次计算 132, 134, 138, 1316 ,无疑是费时费力的。 也可以使用多条算式连接进行快速暴力计算 $$C+1\\to C:B\\times a-p\\times(B\\times a \\div R p)\\to B:\\sqrt{k-C-1}$$ 其中 a是底数， k是指数， p是模数，初始时 0 → C, 1 → B.然后快速按动 =, 直到提示数学错误时，查看 B的值即为答案。如果确信不会多按或少按，也可以去掉用于计数的 C。 3.逆元计算优化 计算逆元通常使用扩展欧几里得算法，不幸的是计算器在此过程中几乎毫无用处。因此，我们考虑以下计算方法计算a在模n下的逆元。 考虑欧拉定理 aϕ(n) = 1 (mod n) 稍作变换 a × aϕ(n) − 1 = 1 (mod n) 即 a−1 = aϕ(n) − 1 (mod n) 其中欧拉函数常需要这样计算 $$\\phi(n) = n(1 - \\frac{1}{p_1})(1 - \\frac{1}{p_2})\\cdots(1-\\frac{1}{p_m})$$ 其中，p1, p2, …, pm 是 n 的所有不同质因数 计算时，先使用FACT功能分解质因数，然后计算欧拉函数值，最后计算aϕ(n) − 1 mod n（可能需要使用快速幂算法） 例如计算75−1 mod 97 发现97是一个素数 ϕ(97) = 97 − 1 = 96 然后计算 75ϕ(97) − 1 = 7595 (mod 97) 考虑 75 ≈ 102, 95 = 5 * 19,先计算 755 mod 97 = 75 考虑 7595 = (755)19 = 7519 = (755)3 × 754 = 753 × 754 = 755 * 752 = 753 (mod 97) 再计算 753 mod 97 = 22 因此 7595 mod 97 = 22 校验 75 × 22 = 1 (mod 97),正确解得 75−1 = 22 (mod 97) 对于a或n较小（不需要使用快速幂）的情况下，该算法固定需要三行算式，考虑快速幂的复杂度也仅为O(logn),与传统扩展欧几里得算法相当。 此外，我们也可以使用表格快速穷举找到逆元。使用表格计算以下函数 f(x) = a × x − p × ((a×x)÷Rp) 找到 $f(x)=1 $对应的 x即为答案。","link":"/2025/06/01/CalculatorUsageInCryptologyExam/"},{"title":"java笔记","text":"第一章 Java编译器：javac 将源程序(.java)编译生成字节码(.class) Java解释器：java 将字节代码在机器上解释执行 垃圾收集在Java程序运行过程中自动进行，程序 员无法精确控制 每个单元可以由： 最多有一条package语句； 任意条import语句； 至少有一个类class声明或接口interface声明构成，public类仅一个 main签名：public static void main(String args[]) args不包含执行文件路径 Java程序的运行需要经过编写、编译、运行三个步骤 第二章 import语句在包语句后，所有类或接口之前。 import语句有两种形式： 1：import 包名.类名; 2：import 包名.*; 在Java语言中，标识符取名的规则： Ø 必须由字母、下划线或美元符开头的； Ø 并由字母、数字、下划线和美元符组成的； Ø 不能与关键字同名 引用类型(数组、class或interface)声明变量时，是不会 为变量(即对象)分配存储空间。它们声明的变量不是数 据本身，而是数据的引用(reference)，需用new运算符 来为引用类型的变量分配贮存空间。new一定会创建新的对象。 Ø 十进制整数是由不以0开头，0～9数字组成数据：12； Ø 八进制整数是由以0开头，0～7数字组成的数据：012； Ø 十六进制整数是由以0x或0X开头，0～9数字及A～F的字 母组成的数据：0x12AB。  整型数常量均为int类型，除非在其后有字母“L” 来表示是长整型long的值 在数值后面不带有任何大小写字母f或d时，表示为double opBt1 &gt;&gt; opBt2 opBt1右移opBt2位 opBt1 &gt;&gt;&gt; opBt2 opBt1无符号右移opBt2 char:utf16 byte, short, char→int → long → float → double &lt;&lt; = 左移位赋值运算符 C &lt;&lt; = 2等价于C = C &lt;&lt; 2 &gt;&gt; = 右移位赋值运算符 C &gt;&gt; = 2等价于C = C &gt;&gt; 2 第三章 break语句也可以带语句标记，它的作用是结束 该语句标记的语句块 continue语句也可以带语句标记，它的作用是结 束该语句标记的外层循环的本次循环。 数组是一个对象，数组声明不能创建对象本身， 而创建一个引用。数组元素由new语句或数组 初始化软件动态分配 必须首先将低位维初始化，才能对它后面的各 维依次初始化，可以创建非矩 形数组的数组。 对字符串数据与其它类型数据使 用“+”运算符连接操作编译时，总是首先将其 它类型数据转换为字符串类型，然后再进行字 符串连接。运算从左至右 Java在一般 对象的基础上进行了优化，将所有的字符串放在了 常量池，当常量池中已有该字符串时则不再新建， 这里没有说明现有常量池中是否有xyz字符串。因 此本题的答案时，如果常量池中没有xyz字符串， 则创建两个StringObject，如果常量池中已有 xyz字符串，则创建一个StringObject String s=new String(“xyz”) 由双引号创建字符串常量，可能合并，new创建string对象，不可合并 1234String a=&quot;123&quot;;String b=&quot;123&quot;;System.out.print(a==b);//true string静态不能加快连接操作，（若不存在）会在常量池创建新的字符串 未初始化string值为null Double不合并，Integer小整数缓存 第四章 在面向对象编程中，继承、多态、封装和抽象是四个基本特性。 成员变量初始化分两种： 创建的变量时初始化值。 例： int a, b; //成员变量a和b都有一个初始值为0。 创建时赋初值； 例： int x = 10, y = 20; //x,y分别赋初值10,20。 在类的构造器中对成员变量的赋初值。 例：Point(){ x = 10; //x赋初值10 y = 20; //y赋初值20 } 使用修饰符final修饰的变量就像常量一样地使用， 称其为常量符号。 常量符号数据只能读取，不能改变。通常常量符号 标识符全用大写字母，单词间用“_”分隔 final在定义时初始化或在构造器中初始化 方法在被调用时，其参数的数据传递是值传递，即实际参数传值给形式参数。对象的值为其地址 由于static 方法不需要创建任何对象，所以它 们不可简单地调用其他那些成员（ static方法 只能访问static成员变量和static方法） 对类对象调用static方法相当于对类调用static方法 第五章 在超类中，由private修饰的访问权限的成员变量 和方法，虽然被子类继承，但是子类不能访问。 子类重写父类的方法（签名相同），权限不能缩小 超类的一个对象（变量）可以被任何从该超类 派生的子类的引用赋值（引用（指向）子类的 实例）。  超类对象（变量）不能访问子类新定义的成员 （变量、方法）  超类对象（变量）引用子类实例，则可以通过 强制转换为子类引用 在子类的创建中，如果出现了与其超类相同的 成员变量，则超类中的成员变量被子类中的成员 变量所隐藏 在子类的创建中，如果出现与超类中有相同名、同参数及同返回类型的成员方法(含static)，则超类中 的成员方法被子类中的成员方法所覆盖。 子类强制转化为父类时，父类成员变量重新表现，而成员方法(非static)及在方法中引用的成员变量被子类重写 父类的static方法不会被覆盖，子类对象转化为父类时会重新表现 父类转换为子类会产生_运行时错误_ this 表示对类的实例访问，它也表示了对象对该实例引用访问。；  在类中可以来指向成员变量，以示区别于非成员变量 super 在子类中，使用super访问被隐藏的超类变量，被覆盖 的超类方法 12345678910class ClassA{void callMe(){System.out.println(&quot;在ClassA中的callMe()方法!&quot;); } }class ClassB extends ClassA{void callMe(){System.out.println(&quot;在ClassB中的callMe()方法!&quot;); } }public class TestConvert{public static void main(String arg[]){ClassA vA = new ClassB();vA.callMe(); } } 程序运行输出的是： 在ClassB中的callMe()方法！ 结果说明了vA调用callMe()是子类ClassB中的方法。 123456789class First{First(){ aMethod(); bMethod();}public void aMethod(){ System.out.println(“in First class”);}public void bMethod(){ System.out.println(&quot;in First class b method&quot;); }}public class Second extends First{Second(){ aMethod(); }public void aMethod(){ System.out.println(“in Second class”);}public static void main(String[ ] args){ new Second( ); }} in Second class in First class b method in Second class 子类构造时，会先调用父类无参数构造器，但构造器与其他成员方法间动态链接，父类构造器可能调用子类重写的成员方法 父类必须具有无参数构造器，否则编译错误 没有重写过的equals()方法和==是一样的，都是比较两个对象引用指向的内存地址是否一 样判断两个对象是否相等，但可以通过重写equals()方法实现依据对象的值来判定是否相等， Java中很多类都自身重写了equals()方法。类似地，要使自定义的对象能正确比较， 第六章 在通用引入和具体引入并存时，使用声明更具体的 包中的类 在都是具体引入并存时，后一个语法错误或使用第 一个具体指明包中的类 在都采用通配符引入时，必须选择正常才能使用 接口中的所有方法都是abstract方法， 这些方法是没有语句 接口默认public，需要被重写 关键字implements不同于extends，它表示类对 接口的实现而不是继承，并且一个类可以实现多个 接口。类实现接口，则必须实现接口中的所有方法 内部类可以调用外部类的成员方法和变量，内部类不能声明static变量和方法 匿名类使用一个类的子类的类体创建对象,只用一次，无构造器，继承父类或实现接口 123people a=new people(){ //ababab}; {}内实现people的子类 可用于访问不同包非子类protect方法、变量 第七章 catch从上到下匹配，若范围小的exception在范围大的exception之下，则会编译时错误。catch子类在前、父类在后。 finally在try/catch后执行，但永远都会在catch/try的return或异常前被执行。catch/try的return结果会被缓存，然后执行finally，如果finally中没有return或异常，则会返回被缓存的结果 throws声明方法可能抛出异常，向上传递 子类重写父类的方法，只能抛出父类能抛出的异常 用户自定义异常是exception子类 throwable有error和exception两个子类 JVM自动处理runtime exception 第八章 节点流：特定位置读写，其余过滤器（中间处理） File类的主要方法： 文件路径和属性  getPath()和getAbsolutePath()方法返回File对象的路径和绝对路径。  getName()方法返回File对象的文件名或目录名。  getParent()返回File对象的父目录。  表示文件的属性或状态： File f = new File(”demo.txt”); f.getName()：获得文件名demo.txt f.exist()：文件demo.txt存在返回true。 canWrite()，canRead()，isDirectory()，isAbsolute()，exist()，isFile() 都返回boolean型数据，分别表示文件是否写保护，是否读保护，是 目录还是文件，是否使用绝对路径，是否存在 创建目录和删除文件  mkdir()和mkdirs()用于创建目录。创建目录的位置完全取决于File对 象的路径。  delete()用于删除文件或目录，删除目录时，应该保证所删目录是一 个空目录，否则删除操作失败。 3. 文件更名  renameTo()方法不但可以给文件更名，而且可以给目录更名。  equals()判断两个File对象是否相等，程序用它来判断用户给定的原文 件名和新文件名是否相等，如果相等则不能进行更名操作。 list()方法产生目录清单，它只返回指定目录中包 含的文件名或子目录名，没有文件长度、修改时 间、文件属性等信息。 lastModified()返回文件最后一次被修改的时间， 其值是相对于1970年1月1日的时间毫秒数，为便 于阅读，必须变成java.util.Date对象 RandomAccessFile，随机读写，由string、file与读写模式构造，写入覆盖原文件对应部分，其他部分不变readInt，writeByte，etc seek移动指针，getFIlePoint。数据类型Byte，Short，Int，Long，Float，Double，Char，Boolean的读写分别在read和write方法作后缀。例：readInt()：读一个int数。writeInt()：写一个int数。 inputstream抽象类，available剩余字节数；skip跳过一定数量；mark(int)标记位置，reset()回到标记位置。  int read() 方法返回一个0至255之间的整数或-1, -1代表遇到了流的结束，其 它对应读入的字节  int read(byte[]) 方法则将字节读入参数给定的字节数组，返回值是实际读入的字 节数或-1(遇到了流结束)  int read(byte[],int,int) 方法的后两个参数分别给出读入的起始位置和读入的最大字节数 outputstream，flush强制输出缓存 int write (int) 向流的末尾写入一个字节的数据 int write (byte[]) 将数组b中的数据依次写入当前的流对象中 int write (byte[],int,int) 将数组中从开始下标(包含)，后续长度的数据依次 写入到流对象中 FileOutputStream支持覆盖、追加 buffered缓冲，由stream初始化，可指定缓冲区大小 Data：readInt，writeByte，etc sequence：将几个stream连接，忽略中间的EOF reader、writer字符单位抽象类 inputstreamreader、outputstreamwriter自动转换Unicode bufferedreader、bufferedwriter pipedinputstream/pipedoutputstream进程线程间通信，input由output构造，output由input构造 1.2 常见的 I/O 类 字节流类： FileInputStream 和 FileOutputStream：用于字节流读取和写入文件。 FileOutputStream(String) FileOutputStream(String,boolean附加为true) FileOutputStream(File) FileOutputStream(FileDescriptor BufferedInputStream 和 BufferedOutputStream：为字节流提供缓冲功能，提高读写性能。 字符流类： FileReader 和 FileWriter：用于字符流读取和写入文件。 BufferedReader 和 BufferedWriter：为字符流提供缓冲功能，提高性能。 数据流类：DataInputStream 和 DataOutputStream：用于读写原始数据类型（如 int、double 等），确保跨平台兼容性。 对象流类：ObjectInputStream 和 ObjectOutputStream：用于读写 Java 对象（需要对象实现 Serializable 接口）。 2. 文件的基本读写操作 2.1 读取文件 使用字节流和字符流可以进行文件的读取操作。 2.1.1 使用 FileInputStream 读取文件（字节流） 1234567891011121314151617import java.io.FileInputStream;import java.io.IOException;public class FileReaderExample { public static void main(String[] args) { String filePath = &quot;example.txt&quot;; try (FileInputStream fileInputStream = new FileInputStream(filePath)) { int byteData; while ((byteData = fileInputStream.read()) != -1) { // 读取文件内容并输出 System.out.print((char) byteData); } } catch (IOException e) { e.printStackTrace(); } }} 2.1.2 使用 FileReader 读取文件（字符流） 123456789101112131415161718import java.io.FileReader;import java.io.BufferedReader;import java.io.IOException;public class FileReaderCharExample { public static void main(String[] args) { String filePath = &quot;example.txt&quot;; try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) { String line; while ((line = reader.readLine()) != null) { // 输出每一行 System.out.println(line); } } catch (IOException e) { e.printStackTrace(); } }} 2.2 写入文件 2.2.1 使用 FileOutputStream 写入文件（字节流） 1234567891011121314import java.io.FileOutputStream;import java.io.IOException;public class FileWriterExample { public static void main(String[] args) { String content = &quot;Hello, Java File I/O!&quot;; try (FileOutputStream fileOutputStream = new FileOutputStream(&quot;output.txt&quot;)) { // 写入字节数据 fileOutputStream.write(content.getBytes()); } catch (IOException e) { e.printStackTrace(); } }} 2.2.2 使用 FileWriter 写入文件（字符流） 123456789101112131415import java.io.FileWriter;import java.io.BufferedWriter;import java.io.IOException;public class FileWriterCharExample { public static void main(String[] args) { String content = &quot;Hello, Java File I/O!&quot;; try (BufferedWriter writer = new BufferedWriter(new FileWriter(&quot;output.txt&quot;))) { // 写入字符串 writer.write(content); } catch (IOException e) { e.printStackTrace(); } }} 12345678910111213141516171819202122public static void main(String[] args) { Worm w=new Worm(6,'a'); System.out.println(&quot;w=&quot;+w); try{ ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(&quot;worm.out&quot;)); out.writeObject(&quot;Worm storage&quot;); out.writeObject(w); out.close(); ObjectInputStream in =new ObjectInputStream(new FileInputStream(&quot;worm.out&quot;)); String s=(String)in.readObject(); Worm w2=(Worm)in.readObject(); System.out.println(s+&quot;,w2=&quot;+w2); }catch(Exception e){ e.printStackTrace(); }} PipedOutputStream producer = new PipedOutputStream(); PipedInputStream consumer = new PipedInputStream(producer); out.writeDouble(num); 123456789101112131415161718192021222324252627282930313233343536import java.io.*;public class Find { public static void main(String args[]) { BufferedReader bRead = null; BufferedWriter bWrite = null; String buffer; boolean outFile = false; int i = 0; try { FileReader fr = new FileReader(new File(args[0])); bRead = new BufferedReader(fr); } catch (IOException e) {} try { FileWriter fw = new FileWriter(new File(args[2])); bWrite = new BufferedWriter(fw); outFile = true; } catch (IOException e) {} try { buffer = bRead.readLine(); while (buffer != null) { if (buffer.indexOf(args[1]) != -1) { if (outFile) { bWrite.write(buffer); bWrite.newLine(); } System.out.println(buffer); i++; } buffer = bRead.readLine(); } } catch (IOException e) { } finally { try { bRead.close(); if (bWrite != null) bWrite.close(); } catch (Exception e) {}}}}","link":"/2025/03/22/java%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"作业","slug":"作业","link":"/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"}],"categories":[],"pages":[{"title":"about","text":"致谢 本blog托管于github，域名由eu.org提供，域名解析与CDN加速由cloudflare提供，在此一并表示感谢。 1234567891011121314-----BEGIN PGP PUBLIC KEY BLOCK-----mDMEZkYOoxYJKwYBBAHaRw8BAQdAxCxygZjf2tW/CSJjP1oW3WQo66I0bOBT0PCyK1CMfwm0HFJ5ZSBTb25nIDxyYWluMTIwMUB5ZWFoLm5ldD6IkwQTFgoAOxYhBJTXOejJmz4E/TCtqakRpkuYg/pWBQJmRg6jAhsDBQsJCAcCAiICBhUKCQgLAgQWAgMBAh4HAheAAAoJEKkRpkuYg/pWyewBAL0ZgD54A6DD65rcd2px4kBeIgj+trl7O57WTf/E2q7GAP95gaeAX1SDnexo4pd+tOdvvsc0a6oJGOgwKktTvIoSC7g4BGZGDqMSCisGAQQBl1UBBQEBB0BlBsZKXvaQQRH4b3J6GCkHvpROTMkjIjr2FJYblurNPwMBCAeIeAQYFgoAIBYhBJTXOejJmz4E/TCtqakRpkuYg/pWBQJmRg6jAhsMAAoJEKkRpkuYg/pWIMEBAMiMoZ7+ir7ZHxXky7h6XMIp4i8XoMu8lxMHBLgCX1hCAP9F8ahbfsU3JuqIsvlIw3xKqusI3ycuEy16QdL7xxbjAA===+BHp-----END PGP PUBLIC KEY BLOCK-----","link":"/about/index.html"}]}